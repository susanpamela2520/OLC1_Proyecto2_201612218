/* parser generated by jison 0.3.0 */
/**
 * Returns a Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

    import { LexicalErrorEx } from './Exceptions/LexicalErrorEx';
    import { Cout } from './Statements/Cout';
    import { Terminal } from "./Expressions/Terminal";
    import { IStatement } from "./Abstract/IStatement";
    import { Terminals } from "./Enums/EnumTerminals";
    import { Execute } from "./Statements/Execute";
    import { Method } from "./Statements/Method";
    import { Terminals } from "./Enums/EnumTerminals";
    import { Terminal } from "./Expressions/Terminal";

import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType, o } from '@ts-jison/parser';const $V0=[1,5],$V1=[1,7],$V2=[1,8],$V3=[5,9,14,21],$V4=[1,22],$V5=[18,23];

export class TsLanguageParser extends JisonParser implements JisonParserApi {
    $?: any;

    constructor (yy = {}, lexer = new TsLanguageLexer(yy)) {
      super(yy, lexer);
    }

    symbols_: SymbolsType = {"error":2,"ini":3,"main_statements":4,"EOF":5,"main_statement":6,"run_st":7,"END_SENT":8,"function":9,"method":10,"standard_statements":11,"standard_statement":12,"print_st":13,"EXECUTE":14,"IDENTIFIER":15,"OP_PARENT":16,"CL_PARENT":17,"COUT":18,"IMP":19,"expr":20,"VOID":21,"OP_BRACE":22,"CL_BRACE":23,"value":24,"DECIMAL":25,"INTEGER":26,"STRING":27,"CHAR":28,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",8:"END_SENT",9:"function",14:"EXECUTE",15:"IDENTIFIER",16:"OP_PARENT",17:"CL_PARENT",18:"COUT",19:"IMP",21:"VOID",22:"OP_BRACE",23:"CL_BRACE",25:"DECIMAL",26:"INTEGER",27:"STRING",28:"CHAR"};
    productions_: ProductionsType = [0,[3,2],[4,2],[4,1],[6,2],[6,1],[6,1],[11,2],[11,1],[12,2],[7,4],[13,4],[10,7],[20,1],[24,1],[24,1],[24,1],[24,1]];
    table: Array<StateType> = [{3:1,4:2,6:3,7:4,9:$V0,10:6,14:$V1,21:$V2},{1:[3]},{5:[1,9],6:10,7:4,9:$V0,10:6,14:$V1,21:$V2},o($V3,[2,3]),{8:[1,11]},o($V3,[2,5]),o($V3,[2,6]),{15:[1,12]},{15:[1,13]},{1:[2,1]},o($V3,[2,2]),o($V3,[2,4]),{16:[1,14]},{16:[1,15]},{17:[1,16]},{17:[1,17]},{8:[2,10]},{22:[1,18]},{11:19,12:20,13:21,18:$V4},{12:24,13:21,18:$V4,23:[1,23]},o($V5,[2,8]),{8:[1,25]},{19:[1,26]},o($V3,[2,12]),o($V5,[2,7]),o($V5,[2,9]),{20:27,24:28,25:[1,29],26:[1,30],27:[1,31],28:[1,32]},{19:[1,33]},{19:[2,13]},{19:[2,14]},{19:[2,15]},{19:[2,16]},{19:[2,17]},{8:[2,11]}];
    defaultActions: {[key:number]: any} = {9:[2,1],16:[2,10],28:[2,13],29:[2,14],30:[2,15],31:[2,16],32:[2,17],33:[2,11]};

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2: case 7:
 $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; 
break;
case 3: case 8:
 this.$ = new Array<IStatement>(); this.$[0] = $$[$0]; 
break;
case 4: case 9:
 this.$ = $$[$0-1]; 
break;
case 5: case 6: case 13:
 this.$ = $$[$0]; 
break;
case 10:
 this.$ = new Execute($$[$0-2], undefined, _$[$0-3].first_line, _$[$0-3].first_column); 
break;
case 11:
 this.$ = new Cout($$[$0-1], _$[$0-3].first_line, _$[$0-3].first_column); 
break;
case 12:
 this.$ = new Method($$[$0-5], undefined, $$[$0-1], _$[$0-6].first_line, _$[$0-6].first_column); 
break;
case 14:
 this.$ = new Terminal(Terminals.DECIMAL, Number($$[$0]), _$[$0].first_line, _$[$0].first_column); 
break;
case 15:
 this.$ = new Terminal(Terminals.INTEGER, Number($$[$0]), _$[$0].first_line, _$[$0].first_column); 
break;
case 16:
 this.$ = new Terminal(Terminals.STRING, $$[$0], _$[$0].first_line, _$[$0].first_column); 
break;
case 17:
 this.$ = new Terminal(Terminals.CHAR, $$[$0], _$[$0].first_line, _$[$0].first_column); 
break;
        }
    }
}


/* generated by ts-jison-lex 0.3.0 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';
export class TsLanguageLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"case-insensitive":true,"moduleName":"TsLanguage"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [/^(?:\s+)/i,/^(?:\/\/.*)/i,/^(?:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/])/i,/^(?:[0-9]+(\.[0-9]+)\b)/i,/^(?:[0-9]+\b)/i,/^(?:True|False\b)/i,/^(?:"((\\")|[\\n]|[\\\\]|[^\"])*")/i,/^(?:'((\\')|[\\n]|[\\\\]|[^\'])?')/i,/^(?:<<)/i,/^(?:;)/i,/^(?:\()/i,/^(?:\))/i,/^(?:\{)/i,/^(?:\})/i,/^(?:cout\b)/i,/^(?:execute\b)/i,/^(?:void\b)/i,/^(?:[0-9a-zA-Z_]+)/i,/^(?:$)/i,/^(?:.)/i];
    conditions: any = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:// ignore whitespaces
      break;
    case 1:// ignore comments
      break;
    case 2:// ignore comments
      break;
    case 3:return 25;
      break;
    case 4:return 26;
      break;
    case 5:return 'LOGICAL';
      break;
    case 6:yy_.yytext=yy_.yytext.substr(1,yy_.yyleng-2); return 27;
      break;
    case 7:yy_.yytext=yy_.yytext.substr(1,yy_.yyleng-2); return 28;
      break;
    case 8:return 19;
      break;
    case 9:return 8;
      break;
    case 10:return 16;
      break;
    case 11:return 17;
      break;
    case 12:return 22;
      break;
    case 13:return 23;
      break;
    case 14:return 18;
      break;
    case 15:return 14;
      break;
    case 16:return 21;
      break;
    case 17:return 15;
      break;
    case 18:return 5; // end of file
      break;
    case 19: 
      break;
        }
    }
}

